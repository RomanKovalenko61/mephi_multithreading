# Отчет по выполненной работе

## Анализ производительности

Самописный пул справляется с возложенными на него обязанностями и выполняет поставленные задачи. В сравнении с библиотечными реализациями
в Tomcat или Jetty он конечно проиграет в плане производительности, но для учебных целей и понимания принципов работы с потоками и пулами потоков он вполне подходит.

## Исследование параметров пула для достижения максимальной производительности

- **corePoolSize**: Оптимально — по числу ядер процессора. Меньше — увеличивает задержки, больше — теряет эффективность.
- **maxPoolSize**: Имеет смысл увеличивать при большом количестве коротких задач. Слишком большое значение приводит к избыточному переключению контекста.
- **queueSize**: Маленькая очередь быстро переполняется, большая — увеличивает задержки. Оптимальные значения находятся в диапазоне 2-4x от corePoolSize.
- **keepAliveTime**: 3-10 секунд — выбор между быстрым освобождением ресурсов и отсутствием частого создания потоков.
- **minSpareThreads**: Значение 1-2 позволяет быстро реагировать на всплески нагрузки.

## Принцип работы балансировки

В пуле реализовано распределение задач по принципу Round Robin: каждая новая задача помещается в очередь следующего воркера по кругу. Это обеспечивает равномерную загрузку потоков и предотвращает переполнение одной очереди при простое других.

Если очередь переполнена, применяется политика отказа, которая настраивается при создании пула. По умолчанию используется `AbortPolicy`, которая просто отбрасывает задачи при переполнении очереди.
Через сеттер можно установить политику CallerRunPolicy, которая позволяет выполнять задачи в вызывающем потоке, если пул не может принять новую задачу.